<!DOCTYPE html>
<!--[if lt IE 7]>       <html class="no-js ie6 oldie" lang="en"> <![endif]-->
<!--[if IE 7]>          <html class="no-js ie7 oldie" lang="en"> <![endif]-->
<!--[if IE 8]>          <html class="no-js ie8 oldie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!-->  <html class="no-js" lang="en"> <!--<![endif]-->
<head>
    <title>concrete syntax tree - Chevrotain</title>
    <meta name="description" content="JavaScript Parser Building Toolkit" />
    <meta name="author" content="Shahar Soel">
    <meta charset="UTF-8">
    <link rel="icon" href="../themes/daux/img/favicon-blue.png" type="image/x-icon">
    <!-- Mobile -->
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Font -->
    <link href='https://fonts.googleapis.com/css?family=Roboto+Slab:400,100,300,700&subset=latin,cyrillic-ext,cyrillic' rel='stylesheet' type='text/css'>
    <!-- CSS -->
    <link href='../themes/daux/css/theme-blue.min.css' rel='stylesheet' type='text/css'>
            <!-- Tipue Search -->
        <link href="../tipuesearch/tipuesearch.css" rel="stylesheet">
    
    <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body class=" ">
    <div class="Columns content">
    <aside class="Columns__left Collapsible">
        <button type="button" class="Button Collapsible__trigger">
            <span class="Collapsible__trigger--bar"></span>
            <span class="Collapsible__trigger--bar"></span>
            <span class="Collapsible__trigger--bar"></span>
        </button>

        <a class="Brand" href="../index.html">Chevrotain</a>

    <div class="Search">
        <svg class="Search__icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 451 451">
            <path d="M447.05 428l-109.6-109.6c29.4-33.8 47.2-77.9 47.2-126.1C384.65 86.2 298.35 0 192.35 0 86.25 0 .05 86.3.05 192.3s86.3 192.3 192.3 192.3c48.2 0 92.3-17.8 126.1-47.2L428.05 447c2.6 2.6 6.1 4 9.5 4s6.9-1.3 9.5-4c5.2-5.2 5.2-13.8 0-19zM26.95 192.3c0-91.2 74.2-165.3 165.3-165.3 91.2 0 165.3 74.2 165.3 165.3s-74.1 165.4-165.3 165.4c-91.1 0-165.3-74.2-165.3-165.4z"/>
        </svg>
        <input type="search" id="tipue_search_input" class="Search__field" placeholder="Search..." autocomplete="on"
               results=25 autosave=text_search>
    </div>

        <div class="Collapsible__content">
            <!-- Navigation -->
            <ul class='Nav'><li class='Nav__item  has-children'><a href="../Tutorial/step1_lexing.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Tutorial</a><ul class='Nav'><li class='Nav__item '><a href="../Tutorial/step1_lexing.html">step1 lexing</a></li><li class='Nav__item '><a href="../Tutorial/step2_parsing.html">step2 parsing</a></li><li class='Nav__item '><a href="../Tutorial/step3_adding_actions_root.html">step3 adding actions root</a></li><li class='Nav__item '><a href="../Tutorial/step3a_adding_actions_visitor.html">step3a adding actions visitor</a></li><li class='Nav__item '><a href="../Tutorial/step3b_adding_actions_embedded.html">step3b adding actions embedded</a></li><li class='Nav__item '><a href="../Tutorial/step4_fault_tolerance.html">step4 fault tolerance</a></li></ul></li><li class='Nav__item Nav__item--open has-children'><a href="../Deep_Dive/concrete_syntax_tree.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Deep Dive</a><ul class='Nav'><li class='Nav__item Nav__item--active'><a href="../Deep_Dive/concrete_syntax_tree.html">concrete syntax tree</a></li><li class='Nav__item '><a href="../Deep_Dive/custom_token_patterns.html">custom token patterns</a></li><li class='Nav__item '><a href="../Deep_Dive/syntactic_content_assist.html">syntactic content assist</a></li></ul></li><li class='Nav__item  has-children'><a href="../Building_Grammars/generating_syntax_diagrams.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Building Grammars</a><ul class='Nav'><li class='Nav__item '><a href="../Building_Grammars/generating_syntax_diagrams.html">generating syntax diagrams</a></li><li class='Nav__item '><a href="../Building_Grammars/resolving_grammar_errors.html">resolving grammar errors</a></li><li class='Nav__item '><a href="../Building_Grammars/resolving_lexer_errors.html">resolving lexer errors</a></li></ul></li><li class='Nav__item '><a href="../FAQ.html">FAQ</a></li><li class='Nav__item '><a href="../Roadmap.html">Roadmap</a></li></ul>

            <div class="Links">
                                    <hr/>
                                            <a href="http://sap.github.io/chevrotain/playground/" target="_blank">Online Playground</a>
                        <br />
                                            <a href="http://sap.github.io/chevrotain/performance/" target="_blank">Performance Benchmark</a>
                        <br />
                                            <a href="https://github.com/sap/chevrotain/issues" target="_blank">Help/Support/Bugs</a>
                        <br />
                                            <a href="https://github.com/sap/chevrotain" target="_blank">GitHub Repo</a>
                        <br />
                                    
                                    <div class="CodeToggler">
                        <hr/>
                                                    <a class="CodeToggler__button CodeToggler__button--main" href="#">Show Code Blocks Inline</a><br>
                                            </div>
                
                            </div>
        </div>
    </aside>
    <div class="Columns__right ">
        <div class="Columns__right__content">
            <div class="doc_content">
                <article class="Page">

    <div class="Page__header">
        <h1><a href="../Deep_Dive/concrete_syntax_tree.html">Deep Dive</a> <svg class="Page__header--separator" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 477.175 477.175"><path d="M360.73 229.075l-225.1-225.1c-5.3-5.3-13.8-5.3-19.1 0s-5.3 13.8 0 19.1l215.5 215.5-215.5 215.5c-5.3 5.3-5.3 13.8 0 19.1 2.6 2.6 6.1 4 9.5 4 3.4 0 6.9-1.3 9.5-4l225.1-225.1c5.3-5.2 5.3-13.8.1-19z"/></svg> <a href="../Deep_Dive/concrete_syntax_tree.html">concrete syntax tree</a></h1>
                <span style="float: left; font-size: 10px; color: gray;">
            Thursday, January 4, 2018 8:30 AM        </span>
                        <span style="float: right; font-size: 10px; color: gray;">
            <a href="https://github.com/SAP/chevrotain/blob/master/docs/02_Deep_Dive/concrete_syntax_tree.md" target="_blank">Edit on GitHub</a>
        </span>
            </div>


    <div class="s-content">
        <h2 id="page_Automatic-Concrete-Syntax-Tree-Creation">Automatic Concrete Syntax Tree Creation</h2>
<p>Chevrotain has the capability to <strong>automatically</strong> create a concrete syntax tree (CST)
during parsing. A CST is a simple structure which represents the entire parse tree.
It contains information on every token parsed.</p>
<p>The main advantage of using the automatic CST creation is that it enables writing &quot;pure&quot; grammars.
This means that the semantic actions are <strong>not</strong> embedded into the grammar implementation but are instead
completely separated from it.</p>
<p>This separation of concerns makes the grammar easier to maintain
and makes it easier to implement different capabilities on the grammar,
for example: separate logic for compilation and for IDE support.</p>
<h3 id="page_Differences-between-an-AST-and-a-CST">Differences between an AST and a CST.</h3>
<p>There are two major differences.</p>
<ol>
<li>
<p>An Abstract Syntax Tree would not normally contain all the syntactic information.
This mean the <strong>exact original</strong> text could not be re-constructed from the AST.</p>
</li>
<li>
<p>An Abstract Syntax Tree would not represent the whole syntactic parse tree.
It would normally only contain nodes related to specific parse tree nodes, but not all of those (mostly leaf nodes).</p>
</li>
</ol>
<h3 id="page_How-to-enable-CST-output">How to enable CST output?</h3>
<p>In the future this capability will be enabled by default.
Currently this feature must be explicitly enabled by setting the <strong>outputCst</strong> flag.</p>
<p>In the parser <a href="http://sap.github.io/chevrotain/documentation/1_0_1/interfaces/iparserconfig.html" class="external">configuration object</a>.</p>
<pre><code class="language-JavaScript">class MyParser extends chevrotain.Parser {

    constructor(input) {
        super(input, allTokens, {outputCst : true})
    }
}        
</code></pre>
<h3 id="page_The-structure-of-the-CST">The structure of the CST</h3>
<p>The structure of the CST is very simple.</p>
<ul>
<li>
<p>Run the CST creation example in the <a href="http://sap.github.io/chevrotain/playground/?example=JSON%20grammar%20and%20automatic%20CST%20output" class="external"><strong>online playground</strong></a>.</p>
</li>
<li>
<p>Note that the following examples are not runnable nor contain the full information.
These are just snippets to explain the core concepts.</p>
</li>
</ul>
<pre><code class="language-TypeScript">export type CstElement = IToken | CstNode
export type CstChildrenDictionary = { [elementName:string]:CstElement[] }

export interface CstNode {
    readonly name:string

    readonly children:CstChildrenDictionary

    readonly recoveredNode?:boolean
}
</code></pre>
<p>A single CstNode corresponds to a single grammar rule's invocation result.</p>
<pre><code class="language-JavaScript">$.RULE(&quot;qualifiedName&quot;, () =&gt; {
    
})

input = &quot;&quot;

output = {
  name: &quot;qualifiedName&quot;,  
  children: {}
}
</code></pre>
<p>Each Terminal will appear in the children dictionary using the terminal's name
as the key and an <strong>array</strong> of IToken as the value.</p>
<pre><code class="language-JavaScript">$.RULE(&quot;qualifiedName&quot;, () =&gt; {
    $.CONSUME(Identifier)
    $.CONSUME(Dot)
    $.CONSUME2(Identifier)
})

input = &quot;foo.bar&quot;

output = {
  name: &quot;qualifiedName&quot;,  
  children: {
      Dot : [&quot;.&quot;],
      Identifier : [&quot;foo&quot;, &quot;bar&quot;]
  }
}
</code></pre>
<p>Non-Terminals are handled similarly to Terminals except each item in the value's array
Is the CstNode of the corresponding Grammar Rule (Non-Terminal).</p>
<pre><code class="language-JavaScript">$.RULE(&quot;qualifiedName&quot;, () =&gt; {
    $.SUBRULE($.singleIdent)      
})

$.RULE(&quot;singleIdent&quot;, () =&gt; {
    $.CONSUME(Identifier)            
})

input = &quot;foo&quot;

output = {
  name: &quot;qualifiedName&quot;,  
  children: {
      singleIdent : [
          {
            name: &quot;singleIdent&quot;,  
            children: {
               Identifier : [&quot;foo&quot;]
            }
        }
      ]
  }
}
</code></pre>
<h3 id="page_In-Lined-Rules">In-Lined Rules</h3>
<p>So far the CST structure is quite simple, but how would a more complex grammar be handled?</p>
<pre><code class="language-JavaScript">$.RULE(&quot;statements&quot;, () =&gt; {
    $.OR([
        // let x = 5
        {ALT: () =&gt; {
            $.CONSUME(Let)
            $.CONSUME(Identifer)
            $.CONSUME(Equals)
            $.SUBRULE($.expression)
        }},
        // select age from employee where age = 120
        {ALT: () =&gt; {
            $.CONSUME(Select)
            $.CONSUME2(Identifer)
            $.CONSUME(From)
            $.CONSUME3(Identifer)
            $.CONSUME(Where)
            $.SUBRULE($.expression)
        }}
    ])
})
</code></pre>
<p>Some of the Terminals and Non-Terminals are used in <strong>both</strong> alternatives.
It is possible to check for the existence of distinguishing terminals such as the &quot;Let&quot; and &quot;Select&quot;.
But this is not a robust approach.</p>
<pre><code class="language-javaScript">let cstResult = parser.qualifiedName()

if (cstResult.children.Let.length &gt; 0) {
    // Let statement
    // do something...
}
else if (cstResult.children.Select.length &gt; 0) {
    // Select statement
    // do something else.
}

</code></pre>
<p>Alternatively it is possible to refactor the grammar in such a way that both alternatives
Would be completely wrapped in their own Non-Terminal rules.</p>
<pre><code class="language-javascript">$.RULE(&quot;statements&quot;, () =&gt; {
    $.OR([
        {ALT: () =&gt; $.SUBRULE($.letStatement)},
        {ALT: () =&gt; $.SUBRULE($.selectStatement)}
    ])
})
</code></pre>
<p>This is the recommended approach in this case as more and more alternations are added the grammar rule
will become too difficult to understand and maintain due to verbosity.</p>
<p>However sometimes refactoring out rules is too much, this is where <strong>in-lined</strong> rules arrive to the rescue.</p>
<pre><code class="language-JavaScript">$.RULE(&quot;statements&quot;, () =&gt; {
    $.OR([
        // let x = 5
        {
         NAME: &quot;$letStatement&quot;,   
         ALT: () =&gt; {
            $.CONSUME(Let)
            $.CONSUME(Identifer)
            $.CONSUME(Equals)
            $.SUBRULE($.expression)
        }},
        // select age from employee where age = 120
        {
         NAME: &quot;$selectStatement&quot;,   
         ALT: () =&gt; {
            $.CONSUME(Select)
            $.CONSUME2(Identifer)
            $.CONSUME(From)
            $.CONSUME3(Identifer)
            $.CONSUME(Where)
            $.SUBRULE($.expression)
        }}
    ])
})

output = {
  name: &quot;statements&quot;,  
  children: {
      $letStatement : [/*...*/],
      $$selectStatement : [/*...*/]
  }
}
</code></pre>
<p>Providing a <strong>NAME</strong> property to the DSL methods will create an in-lined rule.
It is equivalent to extraction to a separate grammar rule with two differences:</p>
<ul>
<li>To avoid naming conflicts in-lined rules <strong>must</strong> start with a dollar($) sign.</li>
<li>In-lined rules do not posses error recovery (re-sync) capabilities as do regular rules.</li>
</ul>
<p>Syntax Limitation:</p>
<ul>
<li>
<p>The <strong>NAME</strong> property of an in-lined rule must appear as the <strong>first</strong> property
of the <strong>DSLMethodOpts</strong> object.</p>
<pre><code class="language-javascript">// GOOD
$.RULE(&quot;field&quot;, () =&gt; {
    $.OPTION({
        NAME:&quot;$modifier&quot;,
        DEF: () =&gt; {
            $.CONSUME(Static) 
        }
    })
})

// Bad - won't work.
$.RULE(&quot;field&quot;, () =&gt; {
   $.OPTION({
       DEF: () =&gt; {
           $.CONSUME(Static) 
       },
       NAME:&quot;$modifier&quot;
   })
})
</code></pre>
</li>
</ul>
<h3 id="page_CST-And-Error-Recovery">CST And Error Recovery</h3>
<p>CST output is also supported in combination with automatic error recovery.
This combination is actually stronger than regular error recovery because
even partially formed CstNodes will be present on the CST output and be marked
using the <strong>recoveredNode&quot;</strong> boolean property.</p>
<p>For example given this grammar and assuming the parser re-synced after a token mismatch at
the &quot;Where&quot; token:</p>
<pre><code class="language-JavaScript">$.RULE(&quot;SelectClause&quot;, () =&gt; {    
    $.CONSUME(Select)
    $.CONSUME2(Identifer)
    $.CONSUME(From)
    $.CONSUME3(Identifer)
    $.CONSUME(Where)
    $.SUBRULE($.expression)
})

// mismatch token due to typo at &quot;wherrrre&quot;, parsing halts and re-syncs to upper rule so 
// the suffix &quot;wherrrre age &gt; 25&quot; is not parsed.
input = &quot;select age from persons wherrrre age &gt; 25&quot;

output = {
  name: &quot;SelectClause&quot;,  
  children: {
      Select: [&quot;select&quot;],
      Identifier: [&quot;age, persons&quot;],
      From: [&quot;from&quot;],
      Where: [/*nothing here, due to parse error*/],
      expression: [/*nothing here, due to parse error*/],
  },
  // This marks a recovered node.
  recoveredNode: true
}
</code></pre>
<p>This accessibility of <strong>partial parsing results</strong> means some post-parsing logic
may be able to perform farther analysis for example: offer auto-fix suggestions or provide better error messages.</p>
<h3 id="page_Traversing-a-CST-Structure">Traversing a CST Structure.</h3>
<p>So we now know how to create a CST and it's internal structure.
But how do we traverse this structure and perform semantic actions?
Examples for such semantic actions:</p>
<ul>
<li>Creation of an Abstract Syntax Tree (AST) to be later used in the rest of the compilation pipeline.</li>
<li>Running the input text in an interpreter, for example a Calculator's grammar and input can be evaluated to
a numerical value.</li>
<li>Extracting specific pieces of information from the input, I.E data mining.</li>
</ul>
<p>One option would be to &quot;manually&quot; recursively &quot;walk&quot; the output CST structure.</p>
<pre><code class="language-javascript">export function toAst(cst) {
	const children = cst.children
	switch (cst.name) {
		case &quot;selectStatement&quot;: {
		    let columnsListCst = children.columnsList[0]
		    let fromClauseCst = children.fromClause[0]
		    
		    let columnsListAst = toAst(columnsListCst)
		    let fromClauseAst = toAst(fromClauseCst)
		    
		    return {
		        type: &quot;SelectStatementAst&quot;,
		        columns: columnsListAst,
		        from: fromClauseAst
		    }
		}
		case &quot;columnsList&quot;: {
		    let columnName = children.identifier[0].image
		    /*...*/
		}
		case &quot;fromClause&quot;: {
		    /*...*/
		}
		default: {
			throw new Error(`CST case handler not implemented for CST node &lt;${cst.name}&gt;`)
		}
	}
}
</code></pre>
<p>This is a valid approach, however it can be somewhat error prone:</p>
<ul>
<li>No validation that the case names match the real names of the CST Nodes.</li>
<li>The validation for missing case handler (default case) depends on attempting to run toAst with invalid input.
(Fail slow instead of fail fast...)</li>
<li>In-Lined Rules may cause ambiguities as they should be matched on the fullName property not the name property.</li>
</ul>
<h4 id="page_A-more-robust-alternative">A more robust alternative.</h4>
<p>For the impatient, See a full runnable example: <a href="https://github.com/SAP/chevrotain/blob/master/examples/grammars/calculator/calculator_pure_grammar.js" class="external">Calculator Grammar with CSTVisitor interpreter</a></p>
<p>Chevrotain provides a CSTVisitor class which can make traversing the CST less error prone.</p>
<pre><code class="language-javascript">
// The base Visitor Class can be accessed via a Parser **instance**.
const BaseCstVisitor = myParserInstance.getBaseCstVisitorConstructor()

class SqlToAstVisitor extends BaseCstVisitor {

    constructor() {
        super()
        // This helper will detect any missing or redundant methods on this visitor
        this.validateVisitor()
    }

    selectStatement(ctx) {
        // ctx.columnsList is an array, while this.visit accepts a CSTNode
        // but if an array is passed to this.visit it will act as though the first element of the array has been passed.
        // this means &quot;this.visit(ctx.columnsList)&quot; is equivalent to &quot;this.visit(ctx.columnsList[0])&quot;
        let columnsListAst = this.visit(ctx.columnsList)
        let fromClauseAst = this.visit(ctx.fromClause)
        		    
        return {
            type: &quot;SelectStatementAst&quot;,
        	columns: columnsListAst,
        	from: fromClauseAst
        }
    }

    columnsList(ctx) {
         let columnName = ctx.identifier[0].image
        /*...*/
    }

    // Optional &quot;IN&quot; argument
    fromClause(ctx, inArg) {
        /*...*/
    }
    
    // Visitor methods for in-lined rules are created by appending the in-lined rule name to the parent rule name.
    fromClause$INLINED_NAME(ctx) {
       /*...*/
    }
}
</code></pre>
<ul>
<li>
<p>Each visitor method will be invoked with the respective CSTNode's children as the first argument
(called ctx in the above example).</p>
</li>
<li>
<p>Recursively visiting None-Terminals can be accomplished by using the <strong>this.visit</strong> method.
It will invoke the appropriate visit method for the CSTNode argument.</p>
</li>
<li>
<p>The <strong>this.visit</strong> method can also be invoked on an array on CSTNodes in that case
It is equivalent to calling it on the first element of the input array.</p>
</li>
<li>
<p>Each visit method can return a value which can be used to combine the traversal results.</p>
</li>
<li>
<p>The <strong>this.validateVisitor()</strong> method can be used to detect missing or redundant visitor methods.</p>
<ul>
<li>For example due to a refactoring of the grammar or a typo.</li>
</ul>
</li>
<li>
<p>Visitor methods support an optional &quot;IN&quot; parameter.</p>
</li>
</ul>
<h4 id="page_Do-we-always-have-to-implement-all-the-visit-methods">Do we always have to implement all the visit methods?</h4>
<p><strong>No</strong>, sometimes we only need to handle a few specific CST Nodes
In that case use <strong>getBaseCstVisitorConstructorWithDefaults()</strong> to get the base visitor constructor.
This base visitor includes a default implementation for all visit methods
which simply invokes <strong>this.visit</strong> on all none terminals in the CSTNode's children.</p>
<pre><code class="language-javascript">// The base Visitor Class can be accessed via a Parser **instance**.
const BaseCstVisitorWithDefaults = myParserInstance.getBaseCstVisitorConstructorWithDefaults()

class SqlColumnNamesVisitor extends BaseCstVisitorWithDefaults {

    constructor() {
        super()
        this.result = []
        this.validateVisitor()
    }

    fromClause(ctx) {
        // collect only the names of the columns
        this.result.push(ctx.Identifier[0].image)
    }
    
    // All other visit methods will be &quot;filled&quot; automatically with the default implementation.
}
</code></pre>
<p>Note that when using a visitor with default visit implementations
It is not possible to return values from the visit methods because
the default implementation does not return any value, only traverses the CST
thus the chain of returned values will be broken.</p>
<h3 id="page_Performance-of-CST-building">Performance of CST building.</h3>
<p>On V8 (Chrome/Node) building the CST was measured at about <strong>65%</strong> of the performance
versus a pure grammar's runtime. This is substantial but considering Chevrotain is already <a href="http://sap.github.io/chevrotain/performance/" class="external">very fast</a>
and that parsing is usually just one part of a larger flow, than unless there a special edge case which requires
maximum performance than the benefits of using the CST (modularity / ease of maintenance) by far outweigh the costs (reduced performance).</p>
<ul>
<li>Online <a href="http://sap.github.io/chevrotain/performance/cst/" class="external">CST Benchmark</a>
</li>
</ul>
    </div>

        <nav>
        <ul class="Pager">
            <li class=Pager--prev><a href="../Tutorial/step4_fault_tolerance.html">Previous</a></li>            <li class=Pager--next><a href="../Deep_Dive/custom_token_patterns.html">Next</a></li>        </ul>
    </nav>
    </article>

            </div>
        </div>
    </div>
</div>

    
    <!-- jQuery -->
    <script src="../themes/daux/js/jquery-1.11.3.min.js"></script>

    <!-- hightlight.js -->
    <script src="../themes/daux/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- JS -->
    
    <script src="../themes/daux/js/daux.js"></script>

            <!-- Tipue Search -->
        <script type="text/javascript" src="../tipuesearch/tipuesearch.js"></script>

        <script>
            window.onunload = function(){}; // force $(document).ready to be called on back/forward navigation in firefox
            $(function() {
                tipuesearch({
                    'base_url': '../'
                });
            });
        </script>
    
</body>
</html>
