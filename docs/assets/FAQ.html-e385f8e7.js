import{_ as l,r as i,o as c,c as p,a as e,b as n,d as a,w as r,e as s}from"./app-cfc36946.js";const u={},d=s('<h1 id="faq" tabindex="-1"><a class="header-anchor" href="#faq" aria-hidden="true">#</a> FAQ</h1><ul><li><a href="#VS_GENERATORS">Why should I use a Parsing DSL instead of a Parser Generator?</a></li><li><a href="#VS_OTHERS">What Differentiates Chevrotain from other Parsing Libraries?</a></li><li><a href="#WHY_ERROR_RECOVERY">Why are Error Recovery / Fault Tolerant capabilities needed in a Parser?</a></li><li><a href="#DEBUGGING">How do I debug my parser?</a></li><li><a href="#NUMERICAL_SUFFIXES">Why are the unique numerical suffixes (CONSUME1/CONSUME2/...) needed for the DSL Rules?</a></li><li><a href="#MINIFIED">Why does Chevrotain not work correctly after I minified my Sources?</a></li><li><a href="#WEBPACK">Why does Chevrotain not work correctly after I webpacked my Sources?</a></li><li><a href="#STUCK_AMBIGUITY">Why does my parser appear to be stuck during its initialization?</a></li></ul><h2 id="VS_GENERATORS" tabindex="-1"><a class="header-anchor" href="#VS_GENERATORS" aria-hidden="true">#</a> Why should I use a Parsing DSL instead of a Parser Generator?</h2><p>A Parser Generator adds an (unnecessary) level of abstraction between the grammar implementation and the actual parser. This is because the grammar is written in a <strong>different</strong> language than the target runtime.</p><ul><li><p>Debugging a generated parser means looking at <strong>different</strong> code than the actual grammar specifications. This generated code is often huge, verbose and hard to understand. On the other hand, when debugging a Parser implemented using a Parsing DSL, The <strong>actual Grammar&#39;s code</strong> the implementer wrote(not generated code) is debugged. So debugging Chevrotain is <strong>just like</strong> debugging any other JavaScript code.</p></li><li><p>No need to handle grammar generation as part of the build process or commit generated files to the source code.</p></li><li><p>No need to learn a new syntax, as Chevrotain is a <strong>Pure</strong> JavasScript Library. instead the problem is reduced to learning a new API.</p></li><li><p>No need for a special editor to write the Grammar, just use your favorite JavaScript editor.</p></li></ul><h2 id="VS_OTHERS" tabindex="-1"><a class="header-anchor" href="#VS_OTHERS" aria-hidden="true">#</a> What Differentiates Chevrotain from other JavaScript Parsing Solutions?</h2>',6),h=e("strong",null,"Performance",-1),m={href:"https://chevrotain.io/performance/",target:"_blank",rel:"noopener noreferrer"},g=e("li",null,[e("p",null,[e("strong",null,"Error Recovery / Fault Tolerance"),n(": With the exception of Antlr4, other JavaScript Parsing Solutions usually do not have Error Recovery capabilities.")])],-1),f=s('<h2 id="WHY_ERROR_RECOVERY" tabindex="-1"><a class="header-anchor" href="#WHY_ERROR_RECOVERY" aria-hidden="true">#</a> Why are Error Recovery / Fault Tolerant capabilities needed in a Parser?</h2><p>When building a standard compiler that should only handle completely valid inputs these capabilities are indeed irrelevant. But for the use case of building Editor Tools / Language Services the parser must be able to handle partially invalid inputs as well. Some examples:</p><ul><li>All syntax errors should be reported and not just the first one.</li><li>Refactoring should work even if there is a missing comma somewhere.</li><li>Autocomplete / Intellisense should work even if there is a syntax error prior to the requested suggestion position.</li></ul><h2 id="DEBUGGING" tabindex="-1"><a class="header-anchor" href="#DEBUGGING" aria-hidden="true">#</a> How do I debug my parser?</h2><p>Just add a breakpoint in your favorites IDE and debug, same as you would for any other JavaScript code. Chevrotain Grammars are <strong>pure</strong> javascript code. No special handling required.</p>',5),v=s(`<h2 id="NUMERICAL_SUFFIXES" tabindex="-1"><a class="header-anchor" href="#NUMERICAL_SUFFIXES" aria-hidden="true">#</a> Why are the unique numerical suffixes (CONSUME1/CONSUME2/...) needed for the DSL Rules?</h2><p>Lets look at an example first:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token constant">RULE</span><span class="token punctuation">(</span><span class="token string">&quot;someRule&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  $<span class="token punctuation">.</span><span class="token constant">OPTION</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    $<span class="token punctuation">.</span><span class="token constant">CONSUME</span><span class="token punctuation">(</span>MyToken<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  $<span class="token punctuation">.</span><span class="token constant">OPTION1</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// A different suffix is not needed because the argument is different!</span>
    $<span class="token punctuation">.</span><span class="token constant">CONSUME</span><span class="token punctuation">(</span>MyOtherToken<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// OPTION has no &quot;named&quot; argument so a different suffix is **always** needed</span>
  <span class="token comment">// within the same top level rule.</span>
  $<span class="token punctuation">.</span><span class="token constant">OPTION2</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    $<span class="token punctuation">.</span><span class="token constant">CONSUME2</span><span class="token punctuation">(</span>MyToken<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This snippet uses three different variations of OPTION(&quot;&quot;|1|2) and two variations of CONSUME(&quot;&quot;|2). This is because during the parsing runtime Chevrotain must be able to <strong>distinguish</strong> between the variations of the <strong>same</strong> Parsing rule.</p><p>The combination of the DSL Rule(OPTION/MANY/CONSUME), the DSL Rule&#39;s optional numerical suffix and the DSL rule&#39;s parameter (if available) are mapped to a <strong>unique</strong> key which Chevrotain uses to <strong>figure out</strong> the current location in the grammar. This location information is then used for many things such as:</p><ul><li>Computing the lookahead function which decides if a DSL rule should be entered or which alternatives should be taken.</li><li>Computing an appropriate error message which includes the list of next valid possible tokens.</li><li>Performing automatic Error Recovery by figuring out &quot;re-sync&quot; tokens.</li></ul><h2 id="MINIFIED" tabindex="-1"><a class="header-anchor" href="#MINIFIED" aria-hidden="true">#</a> Why does Chevrotain not work correctly after I minified my Grammar?</h2><p><s>Chevrotain relies on <strong>Function.prototype.toString()</strong>. This means that certain aggressive minification options can break Chevrotain grammars.</s></p>`,8),k=e("code",null,"Function.prototype.toString",-1),b={href:"http://chevrotain.io/docs/changes/CHANGELOG.html#_6-0-0-8-20-2019",target:"_blank",rel:"noopener noreferrer"},_=e("h2",{id:"WEBPACK",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#WEBPACK","aria-hidden":"true"},"#"),n(" Why does Chevrotain not work correctly after I webpacked my Grammar?")],-1),S=e("p",null,[e("s",null,[n("Chevrotain relies on "),e("strong",null,"Function.prototype.toString()"),n(". This means that certain webpack optimizations can break Chevrotain grammars.")])],-1),y=e("code",null,"Function.prototype.toString",-1),E={href:"http://chevrotain.io/docs/changes/CHANGELOG.html#_6-0-0-8-20-2019",target:"_blank",rel:"noopener noreferrer"},C=e("h2",{id:"STUCK_AMBIGUITY",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#STUCK_AMBIGUITY","aria-hidden":"true"},"#"),n(" Why does my parser appear to be stuck during its initialization?")],-1),I={href:"https://chevrotain.io/documentation/11_0_2/interfaces/IParserConfig.html",target:"_blank",rel:"noopener noreferrer"},R=e("p",null,"To resolve this try reducing the maxLookahead and inspect the ambiguity errors to fix the grammar ambiguity which is the root cause of the problem.",-1);function N(O,T){const t=i("ExternalLinkIcon"),o=i("RouterLink");return c(),p("div",null,[d,e("ul",null,[e("li",null,[e("p",null,[h,n(": Chevrotain is generally faster (often much more so) than other existing JavaScript Parsing Solutions. And can even compete with the performance of hand built parsers. See an "),e("a",m,[n("Online Benchmark"),a(t)]),n(" that compares the performance of JSON Parsers implemented using multiple JavaScript Parsing solutions.")])]),g]),f,e("p",null,[n("Note that the breakpoints may also trigger during the Parser's initialization. See: the "),a(o,{to:"/guide/internals.html#debugging-implications"},{default:r(()=>[n("relevant section")]),_:1}),n(" in grammar recording phase docs.")]),v,e("p",null,[n("The dependence on "),k,n(" was removed in "),e("a",b,[n("version 6.0.0"),a(t)]),n(" of Chevrotain. Special handling is no longer needed during minification scenarios.")]),_,S,e("p",null,[n("The dependence on "),y,n(" was removed in "),e("a",E,[n("version 6.0.0"),a(t)]),n(" of Chevrotain. Special handling is no longer needed during WebPacking scenarios.")]),C,e("p",null,[n("The first time a Chevrotain parser is initialized additional validations and computations are performed. Some of these can take a very long time under certain edge cases. Specifically the detection of ambiguous alternatives when the parser uses a larger than the default "),e("a",I,[n("maxLookahead"),a(t)]),n(" and there are many (thousands) of ambiguous paths.")]),R,e("p",null,[n("Also have a look at the "),a(o,{to:"/guide/initialization_performance.html"},{default:r(()=>[n("Initialization Performance Guide")]),_:1})])])}const x=l(u,[["render",N],["__file","FAQ.html.vue"]]);export{x as default};
