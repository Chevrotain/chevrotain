import{_ as l,r as o,o as p,c as u,b as n,d as t,e as s,a as r,w as d}from"./app-c52f5eff.js";const c={},m={href:"https://github.com/chevrotain/chevrotain/tree/master/examples/tutorial/step4_error_recovery",target:"_blank",rel:"noopener noreferrer"},h={href:"https://chevrotain.io/documentation/11_1_0/classes/CstParser.html#canTokenTypeBeInsertedInRecovery",target:"_blank",rel:"noopener noreferrer"},v={href:"https://chevrotain.io/documentation/11_1_0/classes/CstParser.html#getTokenToInsert",target:"_blank",rel:"noopener noreferrer"},g={href:"https://chevrotain.io/documentation/11_1_0/classes/CstParser.html#canTokenTypeBeDeletedInRecovery",target:"_blank",rel:"noopener noreferrer"},b={href:"https://chevrotain.io/documentation/11_1_0/classes/CstParser.html#constructor",target:"_blank",rel:"noopener noreferrer"},k={href:"https://chevrotain.io/documentation/11_1_0/classes/CstParser.html#RULE",target:"_blank",rel:"noopener noreferrer"},y={href:"https://chevrotain.io/documentation/11_1_0/interfaces/CstNode.html#recoveredNode",target:"_blank",rel:"noopener noreferrer"},f={href:"https://chevrotain.io/documentation/11_1_0/classes/CstParser.html#RULE",target:"_blank",rel:"noopener noreferrer"};function q(w,e){const a=o("ExternalLinkIcon"),i=o("RouterLink");return p(),u("div",null,[e[39]||(e[39]=n("h1",{id:"fault-tolerance",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#fault-tolerance","aria-hidden":"true"},"#"),t(" Fault Tolerance")],-1)),e[40]||(e[40]=n("h3",{id:"tldr",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#tldr","aria-hidden":"true"},"#"),t(" TLDR")],-1)),n("p",null,[n("a",m,[e[0]||(e[0]=t("Run and Debug the source code")),s(a)]),e[1]||(e[1]=t("."))]),e[41]||(e[41]=r(`<h2 id="introduction" tabindex="-1"><a class="header-anchor" href="#introduction" aria-hidden="true">#</a> Introduction</h2><p>In the previous tutorial steps we have learned how to build a parser for a simple grammar. Our parser can handle valid inputs just fine, but what happens if the input is not perfectly valid? For example when building an editor for a programming language, the input is often not completely valid, yet the editor is still expected to provide functionality (outline/auto-complete/navigation/error locations...) even for invalid inputs.</p><p>Chevrotain uses several fault tolerance / error recovery heuristics, which generally follow error recovery heuristics used in Antlr3.</p><h2 id="single-token-insertion" tabindex="-1"><a class="header-anchor" href="#single-token-insertion" aria-hidden="true">#</a> Single Token insertion</h2><p>Happens when:</p><ul><li>A token Y is expected.</li><li>But a token X is found.</li><li>X is a valid token after the missing Y token.</li></ul><p>A Y token will be automatically <strong>inserted</strong> into the token stream.</p><p>For example: in a JSON Grammar colons are used between keys and values.</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// GOOD</span>
<span class="token punctuation">{</span> <span class="token string-property property">&quot;key&quot;</span> <span class="token operator">:</span> <span class="token number">666</span> <span class="token punctuation">}</span>

<span class="token comment">// BAD, missing colon</span>
<span class="token punctuation">{</span> <span class="token string">&quot;key&quot;</span>   <span class="token number">666</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>If we try parsing the &quot;bad&quot; example, after consuming:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token punctuation">{</span> <span class="token string">&quot;key&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>We expect a colon token (Y).</li><li>We will find a number(666) token (X) in the remaining text: &#39;666 }&#39;.</li><li>After the colon token, a number token is valid.</li></ul><p>Therefore the missing colon will be automatically &quot;inserted&quot;.</p><p>This heuristic&#39;s behavior can be customized by the following methods:</p>`,14)),n("ul",null,[n("li",null,[n("p",null,[n("a",h,[e[2]||(e[2]=t("canTokenTypeBeInsertedInRecovery")),s(a)])])]),n("li",null,[n("p",null,[n("a",v,[e[3]||(e[3]=t("getTokenToInsert")),s(a)])])])]),e[42]||(e[42]=r(`<h2 id="single-token-deletion" tabindex="-1"><a class="header-anchor" href="#single-token-deletion" aria-hidden="true">#</a> Single Token deletion:</h2><p>Happens when:</p><ul><li>A token Y is expected.</li><li>But a token X is found.</li><li>And immediately after X an Y is found.</li></ul><p>The unexpected token X will be skipped (<strong>deleted</strong>) and the parsing will continue.</p><p>For example: lets look at the case of a</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// GOOD</span>
<span class="token punctuation">{</span> <span class="token string-property property">&quot;key&quot;</span> <span class="token operator">:</span> <span class="token number">666</span><span class="token punctuation">}</span>

<span class="token comment">// BAD, redundant &quot;}&quot;</span>
<span class="token punctuation">{</span> <span class="token string">&quot;key&quot;</span> <span class="token punctuation">}</span><span class="token operator">:</span> <span class="token number">666</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>If we try parsing the &quot;bad&quot; example, after consuming:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token punctuation">{</span> <span class="token string">&quot;key&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>We are expecting a colon token (Y).</li><li>But we found right brackets (X) instead.</li><li>The next token (&quot;ðŸ˜Š is a colon token (Y) which the one we originally expected.</li></ul><p>Therefore the redundant right brackets &quot;}&quot; will be skipped (deleted) and the parser will consume the number token.</p><p>This heuristic&#39;s behavior can be customized by the following method:</p>`,11)),n("ul",null,[n("li",null,[n("a",g,[e[4]||(e[4]=t("canTokenTypeBeDeletedInRecovery")),s(a)])])]),e[43]||(e[43]=r(`<h2 id="re-sync-recovery" tabindex="-1"><a class="header-anchor" href="#re-sync-recovery" aria-hidden="true">#</a> Re-Sync Recovery</h2><p>The following re-sync recovery examples use this sample json like grammar:</p><div class="language-ANTLR line-numbers-mode" data-ext="ANTLR"><pre class="language-ANTLR"><code>object
   : &quot;{&quot; objectItem (comma objectItem)* &quot;}&quot;

objectItem
   : stringLiteral &quot;:&quot; value

value
   : object | stringLiteral | number | ...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="repetition-re-sync" tabindex="-1"><a class="header-anchor" href="#repetition-re-sync" aria-hidden="true">#</a> Repetition Re-Sync</h2><p>Repetition re-sync recovery happens when:</p><ul><li>The parser is in a repetition(MANY/AT_LEAST_ONE/MANY_SEP/AT_LEAST_ONE_SEP).</li><li>The parser has consumed the last iteration and is about to &quot;exit&quot; the repetition.</li><li>The next token X is invalid right after the repetition ended.</li></ul><p>In such a situation the parser will attempt to skip tokens until it detects the beginning of a another iteration of the repetition <strong>or</strong> the token it originally expected after the last iteration.</p><p>There are a couple of edge cases in which <strong>other</strong> recovery methods will be preferred:</p><ul><li>If single token insertion/deletion can be performed, it is always preferred as it skips fewer tokens.</li><li>If between rules re-sync recovery can be performed (see below) <strong>and</strong> it can be done by skipping <strong>fewer</strong> tokens. Between rules re-sync will be preferred over repetition re-sync recovery. The same principle applies, the heuristics are greedy and &quot;prefer&quot; to skip the fewest number of tokens.</li></ul><p>Example:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token punctuation">{</span>
  <span class="token string-property property">&quot;key1&quot;</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token string-property property">&quot;key2&quot;</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token number">666</span> <span class="token comment">// &#39;666&#39; should not appear here!</span>
  &quot;key3  <span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
  &quot;key4  <span class="token operator">:</span> <span class="token number">4</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>If we try parsing this input example, after consuming:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token punctuation">{</span>
  <span class="token string-property property">&quot;key1&quot;</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token string-property property">&quot;key2&quot;</span> <span class="token operator">:</span> <span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>The parser in in a repetition of **(comma objectItem)* **</li><li>After consuming &#39;&quot;key2&quot; : 2&#39; the parser &quot;thinks&quot; it has consumed the last iteration as the next comma is missing.</li><li>The next token (X) encountered is &quot;666&quot; which is invalid in that position as the parser expected a &quot;}&quot; after the repetition ends.</li><li>The parser will throw away the following tokens [666, &quot;key3&quot;, :, 3] and re-sync to the next comma (,) to continue a another iteration.</li></ul><p>Note that in such a situation some input would be lost, (the third key), however the fourth key will still be parsed successfully!</p><h2 id="general-re-sync" tabindex="-1"><a class="header-anchor" href="#general-re-sync" aria-hidden="true">#</a> General Re-Sync</h2><p>General re-sync recovery happens when the parser encounters a parser error inside a rule which it cannot recover from in other ways. For example:</p><ul><li>An unexpected Token as been found (MisMatchTokenException) but single token insertion/deletion cannot resolve it.</li><li>None of the alternatives in an OR match.</li><li>A Repetition of AT_LEAST_ONE cannot match even one iteration.</li><li>...</li></ul><p>In re-sync recovery the parser will skip tokens from the token stream until it detects a point it can continue parsing from. The parser will try to skip as few tokens as possible and re-sync to the closest rule in the rule stack.</p><p><strong>An Abstract example:</strong></p><ul><li>Grammar Rule A called Grammar Rule B which called Grammar Rule C (A -&gt; B -&gt; C).</li><li>In Grammar Rule C a parsing error happened which we can not recover from.</li><li>The Parser will now skip tokens until it find a token that can appear immediately after either: <ul><li>The call of C in B</li><li>The call of B in A</li></ul></li></ul><p><strong>A concrete example:</strong></p><p>For the following invalid json input:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token punctuation">{</span>
	<span class="token string-property property">&quot;firstName&quot;</span><span class="token operator">:</span> <span class="token string">&quot;John&quot;</span><span class="token punctuation">,</span>
	<span class="token string-property property">&quot;someData&quot;</span><span class="token operator">:</span>
	   <span class="token punctuation">{</span> <span class="token string-property property">&quot;bad&quot;</span> <span class="token operator">:</span><span class="token operator">:</span> <span class="token string">&quot;part&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// &lt;-- too many colons in the nested object</span>
	<span class="token string-property property">&quot;isAlive&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
	<span class="token string-property property">&quot;age&quot;</span><span class="token operator">:</span> <span class="token number">25</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>When encountering the redundant colon the rule stack will be as follows:</p><ul><li><strong>object</strong> --&gt; top level object</li><li><strong>objectItem</strong> --&gt; &quot;someData&quot;: ... - second item in the top level object</li><li><strong>value</strong> --&gt; { &quot;bad&quot; :: &quot;part&quot; } - the value of the &quot;someData&quot; key</li><li><strong>object</strong> --&gt; { &quot;bad&quot; :: &quot;part&quot; } - the value of the &quot;someData&quot; key</li><li><strong>objectItem</strong> --&gt; &quot;bad&quot; :: &quot;part&quot; - the single item in the inner object.</li><li><strong>value</strong> --&gt; : &quot;part&quot; - the value with the colon prefix</li></ul></li><li><p>The redundant colon will cause an error (NoViableAltException) as the value rule will not be able to decide which alternative to take as none would match.</p></li><li><p>This means the parser needs to find a token to synchronize to, lets check the options:</p><ul><li>After value called by ObjectItem --&gt; none</li><li>After objectItem called by object --&gt; comma.</li><li>After object called by value --&gt; none.</li><li>After value called by ObjectItem --&gt; none</li><li>after objectItem called by object --&gt; comma (again).</li></ul></li><li><p>so the Parser will re-sync to the closest ObjectItem if it finds a comma in the remaining token stream.</p></li><li><p>Therefore the following tokens will be skipped: [&#39;:&#39;, &#39;&quot;part&quot;&#39;, &#39;}&#39;]</p></li><li><p>And the Parser continue from the &quot;nearest&quot; objectItem rule as if it was successfully invoked.</p></li><li><p>Thus the next two items will appear be parsed successfully even though they were preceded by a syntax error!</p></li></ul><h2 id="enabling" tabindex="-1"><a class="header-anchor" href="#enabling" aria-hidden="true">#</a> Enabling</h2>`,26)),n("p",null,[e[6]||(e[6]=t("By default fault tolerance and error recovery heuristics are ")),e[7]||(e[7]=n("strong",null,"disabled",-1)),e[8]||(e[8]=t(". They can be enabled by passing a optional ")),e[9]||(e[9]=n("strong",null,"recoveryEnabled",-1)),e[10]||(e[10]=t(" parameter (default true) To the parser's constructor ")),n("a",b,[e[5]||(e[5]=t("constructor")),s(a)]),e[11]||(e[11]=t("."))]),n("p",null,[e[13]||(e[13]=t("Once enabled specific rules may have their re-sync recovery disabled explicitly, This is can be done during the definition of the grammar rule ")),n("a",k,[e[12]||(e[12]=t("RULE")),s(a)]),e[14]||(e[14]=t(". The third parameter(")),e[15]||(e[15]=n("strong",null,"config",-1)),e[16]||(e[16]=t(") may contain a ")),e[17]||(e[17]=n("strong",null,"resyncEnabled",-1)),e[18]||(e[18]=t(" property that controls whether or not re-sync is enabled for the ")),e[19]||(e[19]=n("strong",null,"specific",-1)),e[20]||(e[20]=t(" rule."))]),e[44]||(e[44]=n("h2",{id:"cst-integration",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#cst-integration","aria-hidden":"true"},"#"),t(" CST Integration")],-1)),n("p",null,[e[23]||(e[23]=t("When using ")),s(i,{to:"/guide/concrete_syntax_tree.html"},{default:d(()=>e[21]||(e[21]=[t("Concrete Syntax Tree")])),_:1}),e[24]||(e[24]=t(" output A re-synced will return a CSTNode with the boolean ")),n("a",y,[e[22]||(e[22]=t('"recoveredNode"')),s(a)]),e[25]||(e[25]=t(" flag marked as true. Additionally a recovered node ")),e[26]||(e[26]=n("strong",null,"may not",-1)),e[27]||(e[27]=t(" have all its contents (children dictionary) filled as only the Terminals and None-Terminals encountered ")),e[28]||(e[28]=n("strong",null,"before",-1)),e[29]||(e[29]=t(" the error which triggered the re-sync will be present. This means that code that handles the CST (CST Walker or Visitor) ")),e[30]||(e[30]=n("strong",null,"must not",-1)),e[31]||(e[31]=t(" assume certain content is always present on a CstNode. Instead it must be very defensive to avoid runtime errors."))]),e[45]||(e[45]=n("h2",{id:"embedded-actions-integration",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#embedded-actions-integration","aria-hidden":"true"},"#"),t(" Embedded Actions Integration")],-1)),e[46]||(e[46]=n("p",null,'Just being able to continue parsing is not enough, as "someone" probably expects a returned value from the sub-rule we have recovered from.',-1)),e[47]||(e[47]=n("p",null,[t("By default "),n("strong",null,"undefined"),t(" will be returned from a recovered rule, however this should most likely be customize in any but the most simple cases.")],-1)),n("p",null,[e[33]||(e[33]=t("Customization is done during the definition of the grammar ")),n("a",f,[e[32]||(e[32]=t("RULE")),s(a)]),e[34]||(e[34]=t(". The third parameter(")),e[35]||(e[35]=n("strong",null,"config",-1)),e[36]||(e[36]=t(") may contain a ")),e[37]||(e[37]=n("strong",null,"recoveryValueFunc",-1)),e[38]||(e[38]=t(" property which is a function that will be invoked to produce the returned value in case of re-sync recovery."))]),e[48]||(e[48]=n("h2",{id:"types-of-recovery-strategies",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#types-of-recovery-strategies","aria-hidden":"true"},"#"),t(" Types Of Recovery Strategies")],-1)),e[49]||(e[49]=n("ul",null,[n("li",null,'Single Token insertion/deletion and repetition re-sync are "in rule" recovery strategies.'),n("li",null,'General re-sync Recovery is a "between rules" recovery strategy.')],-1)),e[50]||(e[50]=n("p",null,`The main difference is that "in-rule" recovery fixes the problem in the scope of a single rule without changes to the parser's rule stack and the parser's output will still be valid.`,-1)),e[51]||(e[51]=n("p",null,'But "Between Rules" recovery will fail at least one parsing rule (and perhaps many more). Thus the latter tends to "lose" more of the original input, may potentially causes invalid output structure (e.g: partial CST structure) and require additional definitions (e.g: what should be returned value of a re-synced rule?).',-1))])}const x=l(c,[["render",q],["__file","step4_fault_tolerance.html.vue"]]);export{x as default};
