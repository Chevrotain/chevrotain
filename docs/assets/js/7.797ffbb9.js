(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{366:function(t,e,a){"use strict";a.r(e);var n=a(33),r=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"faq"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#faq"}},[t._v("#")]),t._v(" FAQ")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#VS_GENERATORS"}},[t._v("Why should I use a Parsing DSL instead of a Parser Generator?")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#VS_OTHERS"}},[t._v("What Differentiates Chevrotain from other Parsing Libraries?")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#WHY_ERROR_RECOVERY"}},[t._v("Why are Error Recovery / Fault Tolerant capabilities needed in a Parser?")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#DEBUGGING"}},[t._v("How do I debug my parser?")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#NUMERICAL_SUFFIXES"}},[t._v("Why are the unique numerical suffixes (CONSUME1/CONSUME2/...) needed for the DSL Rules?")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#MINIFIED"}},[t._v("Why does Chevrotain not work correctly after I minified my Sources?")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#WEBPACK"}},[t._v("Why does Chevrotain not work correctly after I webpacked my Sources?")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#STUCK_AMBIGUITY"}},[t._v("Why does my parser appear to be stuck during its initialization?")])])]),t._v(" "),a("h2",{attrs:{id:"VS_GENERATORS"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#VS_GENERATORS"}},[t._v("#")]),t._v(" Why should I use a Parsing DSL instead of a Parser Generator?")]),t._v(" "),a("p",[t._v("A Parser Generator adds an (unnecessary) level of abstraction between the grammar implementation and the actual parser.\nThis is because the grammar is written in a "),a("strong",[t._v("different")]),t._v(" language than the target runtime.")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("Debugging a generated parser means looking at "),a("strong",[t._v("different")]),t._v(" code than the actual grammar specifications.\nThis generated code is often huge, verbose and hard to understand. On the other hand, when debugging a Parser\nimplemented using a Parsing DSL, The "),a("strong",[t._v("actual Grammar's code")]),t._v(" the implementer wrote(not generated code) is debugged.\nSo debugging Chevrotain is "),a("strong",[t._v("just like")]),t._v(" debugging any other JavaScript code.")])]),t._v(" "),a("li",[a("p",[t._v("No need to handle grammar generation as part of the build process or commit generated files to the source code.")])]),t._v(" "),a("li",[a("p",[t._v("No need to learn a new syntax, as Chevrotain is a "),a("strong",[t._v("Pure")]),t._v(" JavasScript Library. instead the problem is reduced to learning a new API.")])]),t._v(" "),a("li",[a("p",[t._v("No need for a special editor to write the Grammar, just use your favorite JavaScript editor.")])])]),t._v(" "),a("h2",{attrs:{id:"VS_OTHERS"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#VS_OTHERS"}},[t._v("#")]),t._v(" What Differentiates Chevrotain from other JavaScript Parsing Solutions?")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("Performance")]),t._v(": Chevrotain is generally faster (often much more so) than other existing JavaScript Parsing Solutions.\nAnd can even compete with the performance of hand built parsers.\nSee an "),a("a",{attrs:{href:"https://sap.github.io/chevrotain/performance/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Online Benchmark"),a("OutboundLink")],1),t._v(" that compares the performance of JSON Parsers implemented using multiple JavaScript Parsing solutions.")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("Error Recovery / Fault Tolerance")]),t._v(": With the exception of Antlr4, other JavaScript Parsing Solutions usually do not have Error Recovery capabilities.")])])]),t._v(" "),a("h2",{attrs:{id:"WHY_ERROR_RECOVERY"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#WHY_ERROR_RECOVERY"}},[t._v("#")]),t._v(" Why are Error Recovery / Fault Tolerant capabilities needed in a Parser?")]),t._v(" "),a("p",[t._v("When building a standard compiler that should only handle completely valid inputs these capabilities are indeed irrelevant.\nBut for the use case of building Editor Tools / Language Services the parser must be able to handle partially invalid inputs as well.\nSome examples:")]),t._v(" "),a("ul",[a("li",[t._v("All syntax errors should be reported and not just the first one.")]),t._v(" "),a("li",[t._v("Refactoring should work even if there is a missing comma somewhere.")]),t._v(" "),a("li",[t._v("Autocomplete / Intellisense should work even if there is a syntax error prior to the requested suggestion position.")])]),t._v(" "),a("h2",{attrs:{id:"DEBUGGING"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#DEBUGGING"}},[t._v("#")]),t._v(" How do I debug my parser?")]),t._v(" "),a("p",[t._v("Just add a breakpoint in your favorites IDE and debug, same as you would for any other JavaScript code.\nChevrotain Grammars are "),a("strong",[t._v("pure")]),t._v(" javascript code. No special handling required.")]),t._v(" "),a("p",[t._v("Note that the breakpoints may also trigger during the Parser's initialization.\nSee: the "),a("RouterLink",{attrs:{to:"/guide/internals.html#debugging-implications"}},[t._v("relevant section")]),t._v(" in grammar recording phase docs.")],1),t._v(" "),a("h2",{attrs:{id:"NUMERICAL_SUFFIXES"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#NUMERICAL_SUFFIXES"}},[t._v("#")]),t._v(" Why are the unique numerical suffixes (CONSUME1/CONSUME2/...) needed for the DSL Rules?")]),t._v(" "),a("p",[t._v("Lets look at an example first:")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("RULE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"someRule"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  $"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("OPTION")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    $"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CONSUME")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("MyToken"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n  $"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("OPTION1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// A different suffix is not needed because the argument is different!")]),t._v("\n    $"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CONSUME")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("MyOtherToken"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// OPTION has no "named" argument so a different suffix is **always** needed')]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// within the same top level rule.")]),t._v("\n  $"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("OPTION2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    $"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CONSUME2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("MyToken"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v('This snippet uses three different variations of OPTION(""|1|2) and two variations of CONSUME(""|2).\nThis is because during the parsing runtime Chevrotain must be able to '),a("strong",[t._v("distinguish")]),t._v(" between the variations of the "),a("strong",[t._v("same")]),t._v(" Parsing rule.")]),t._v(" "),a("p",[t._v("The combination of the DSL Rule(OPTION/MANY/CONSUME), the DSL Rule's optional numerical suffix and the DSL rule's parameter (if available)\nare mapped to a "),a("strong",[t._v("unique")]),t._v(" key which Chevrotain uses to "),a("strong",[t._v("figure out")]),t._v(" the current location in the grammar. This location information is then\nused for many things such as:")]),t._v(" "),a("ul",[a("li",[t._v("Computing the lookahead function which decides if a DSL rule should be entered or which alternatives should be taken.")]),t._v(" "),a("li",[t._v("Computing an appropriate error message which includes the list of next valid possible tokens.")]),t._v(" "),a("li",[t._v('Performing automatic Error Recovery by figuring out "re-sync" tokens.')])]),t._v(" "),a("h2",{attrs:{id:"MINIFIED"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#MINIFIED"}},[t._v("#")]),t._v(" Why does Chevrotain not work correctly after I minified my Grammar?")]),t._v(" "),a("p",[a("s",[t._v("Chevrotain relies on "),a("strong",[t._v("Function.prototype.toString()")]),t._v(".\nThis means that certain aggressive minification options can break Chevrotain grammars.")])]),t._v(" "),a("p",[t._v("The dependence on "),a("code",[t._v("Function.prototype.toString")]),t._v(" was removed in\n"),a("a",{attrs:{href:"http://sap.github.io/chevrotain/docs/changes/CHANGELOG.html#_6-0-0-8-20-2019",target:"_blank",rel:"noopener noreferrer"}},[t._v("version 6.0.0"),a("OutboundLink")],1),t._v(" of Chevrotain.\nSpecial handling is no longer needed during minification scenarios.")]),t._v(" "),a("h2",{attrs:{id:"WEBPACK"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#WEBPACK"}},[t._v("#")]),t._v(" Why does Chevrotain not work correctly after I webpacked my Grammar?")]),t._v(" "),a("p",[a("s",[t._v("Chevrotain relies on "),a("strong",[t._v("Function.prototype.toString()")]),t._v(".\nThis means that certain webpack optimizations can break Chevrotain grammars.")])]),t._v(" "),a("p",[t._v("The dependence on "),a("code",[t._v("Function.prototype.toString")]),t._v(" was removed in\n"),a("a",{attrs:{href:"http://sap.github.io/chevrotain/docs/changes/CHANGELOG.html#_6-0-0-8-20-2019",target:"_blank",rel:"noopener noreferrer"}},[t._v("version 6.0.0"),a("OutboundLink")],1),t._v(" of Chevrotain.\nSpecial handling is no longer needed during WebPacking scenarios.")]),t._v(" "),a("h2",{attrs:{id:"STUCK_AMBIGUITY"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#STUCK_AMBIGUITY"}},[t._v("#")]),t._v(" Why does my parser appear to be stuck during its initialization?")]),t._v(" "),a("p",[t._v("The first time a Chevrotain parser is initialized additional validations and computations are performed.\nSome of these can take a very long time under certain edge cases. Specifically the detection of ambiguous alternatives\nwhen the parser uses a larger than the default "),a("a",{attrs:{href:"https://sap.github.io/chevrotain/documentation/7_0_1/interfaces/iparserconfig.html#maxlookahead",target:"_blank",rel:"noopener noreferrer"}},[t._v("maxLookahead"),a("OutboundLink")],1),t._v("\nand there are many (thousands) of ambiguous paths.")]),t._v(" "),a("p",[t._v("To resolve this try reducing the maxLookahead and inspect the ambiguity errors to fix\nthe grammar ambiguity which is the root cause of the problem.")]),t._v(" "),a("p",[t._v("Also have a look at the "),a("RouterLink",{attrs:{to:"/guide/initialization_performance.html"}},[t._v("Initialization Performance Guide")])],1)])}),[],!1,null,null,null);e.default=r.exports}}]);