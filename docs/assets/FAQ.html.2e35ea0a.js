import{_ as l,r as i,o as c,c as p,a as e,b as a,w as r,d as s,e as n}from"./app.ca20ebd6.js";const u={},d=s('<h1 id="faq" tabindex="-1"><a class="header-anchor" href="#faq" aria-hidden="true">#</a> FAQ</h1><ul><li><a href="#VS_GENERATORS">Why should I use a Parsing DSL instead of a Parser Generator?</a></li><li><a href="#VS_OTHERS">What Differentiates Chevrotain from other Parsing Libraries?</a></li><li><a href="#WHY_ERROR_RECOVERY">Why are Error Recovery / Fault Tolerant capabilities needed in a Parser?</a></li><li><a href="#DEBUGGING">How do I debug my parser?</a></li><li><a href="#NUMERICAL_SUFFIXES">Why are the unique numerical suffixes (CONSUME1/CONSUME2/...) needed for the DSL Rules?</a></li><li><a href="#MINIFIED">Why does Chevrotain not work correctly after I minified my Sources?</a></li><li><a href="#WEBPACK">Why does Chevrotain not work correctly after I webpacked my Sources?</a></li><li><a href="#STUCK_AMBIGUITY">Why does my parser appear to be stuck during its initialization?</a></li></ul><h2 id="VS_GENERATORS" tabindex="-1"><a class="header-anchor" href="#VS_GENERATORS" aria-hidden="true">#</a> Why should I use a Parsing DSL instead of a Parser Generator?</h2><p>A Parser Generator adds an (unnecessary) level of abstraction between the grammar implementation and the actual parser. This is because the grammar is written in a <strong>different</strong> language than the target runtime.</p><ul><li><p>Debugging a generated parser means looking at <strong>different</strong> code than the actual grammar specifications. This generated code is often huge, verbose and hard to understand. On the other hand, when debugging a Parser implemented using a Parsing DSL, The <strong>actual Grammar&#39;s code</strong> the implementer wrote(not generated code) is debugged. So debugging Chevrotain is <strong>just like</strong> debugging any other JavaScript code.</p></li><li><p>No need to handle grammar generation as part of the build process or commit generated files to the source code.</p></li><li><p>No need to learn a new syntax, as Chevrotain is a <strong>Pure</strong> JavasScript Library. instead the problem is reduced to learning a new API.</p></li><li><p>No need for a special editor to write the Grammar, just use your favorite JavaScript editor.</p></li></ul><h2 id="VS_OTHERS" tabindex="-1"><a class="header-anchor" href="#VS_OTHERS" aria-hidden="true">#</a> What Differentiates Chevrotain from other JavaScript Parsing Solutions?</h2>',6),h=e("strong",null,"Performance",-1),m=n(": Chevrotain is generally faster (often much more so) than other existing JavaScript Parsing Solutions. And can even compete with the performance of hand built parsers. See an "),g={href:"https://chevrotain.io/performance/",target:"_blank",rel:"noopener noreferrer"},f=n("Online Benchmark"),_=n(" that compares the performance of JSON Parsers implemented using multiple JavaScript Parsing solutions."),v=e("li",null,[e("p",null,[e("strong",null,"Error Recovery / Fault Tolerance"),n(": With the exception of Antlr4, other JavaScript Parsing Solutions usually do not have Error Recovery capabilities.")])],-1),k=s('<h2 id="WHY_ERROR_RECOVERY" tabindex="-1"><a class="header-anchor" href="#WHY_ERROR_RECOVERY" aria-hidden="true">#</a> Why are Error Recovery / Fault Tolerant capabilities needed in a Parser?</h2><p>When building a standard compiler that should only handle completely valid inputs these capabilities are indeed irrelevant. But for the use case of building Editor Tools / Language Services the parser must be able to handle partially invalid inputs as well. Some examples:</p><ul><li>All syntax errors should be reported and not just the first one.</li><li>Refactoring should work even if there is a missing comma somewhere.</li><li>Autocomplete / Intellisense should work even if there is a syntax error prior to the requested suggestion position.</li></ul><h2 id="DEBUGGING" tabindex="-1"><a class="header-anchor" href="#DEBUGGING" aria-hidden="true">#</a> How do I debug my parser?</h2><p>Just add a breakpoint in your favorites IDE and debug, same as you would for any other JavaScript code. Chevrotain Grammars are <strong>pure</strong> javascript code. No special handling required.</p>',5),b=n("Note that the breakpoints may also trigger during the Parser's initialization. See: the "),S=n("relevant section"),y=n(" in grammar recording phase docs."),E=s(`<h2 id="NUMERICAL_SUFFIXES" tabindex="-1"><a class="header-anchor" href="#NUMERICAL_SUFFIXES" aria-hidden="true">#</a> Why are the unique numerical suffixes (CONSUME1/CONSUME2/...) needed for the DSL Rules?</h2><p>Lets look at an example first:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token constant">RULE</span><span class="token punctuation">(</span><span class="token string">&quot;someRule&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  $<span class="token punctuation">.</span><span class="token constant">OPTION</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    $<span class="token punctuation">.</span><span class="token constant">CONSUME</span><span class="token punctuation">(</span>MyToken<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  $<span class="token punctuation">.</span><span class="token constant">OPTION1</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// A different suffix is not needed because the argument is different!</span>
    $<span class="token punctuation">.</span><span class="token constant">CONSUME</span><span class="token punctuation">(</span>MyOtherToken<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token comment">// OPTION has no &quot;named&quot; argument so a different suffix is **always** needed</span>
  <span class="token comment">// within the same top level rule.</span>
  $<span class="token punctuation">.</span><span class="token constant">OPTION2</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    $<span class="token punctuation">.</span><span class="token constant">CONSUME2</span><span class="token punctuation">(</span>MyToken<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This snippet uses three different variations of OPTION(&quot;&quot;|1|2) and two variations of CONSUME(&quot;&quot;|2). This is because during the parsing runtime Chevrotain must be able to <strong>distinguish</strong> between the variations of the <strong>same</strong> Parsing rule.</p><p>The combination of the DSL Rule(OPTION/MANY/CONSUME), the DSL Rule&#39;s optional numerical suffix and the DSL rule&#39;s parameter (if available) are mapped to a <strong>unique</strong> key which Chevrotain uses to <strong>figure out</strong> the current location in the grammar. This location information is then used for many things such as:</p><ul><li>Computing the lookahead function which decides if a DSL rule should be entered or which alternatives should be taken.</li><li>Computing an appropriate error message which includes the list of next valid possible tokens.</li><li>Performing automatic Error Recovery by figuring out &quot;re-sync&quot; tokens.</li></ul><h2 id="MINIFIED" tabindex="-1"><a class="header-anchor" href="#MINIFIED" aria-hidden="true">#</a> Why does Chevrotain not work correctly after I minified my Grammar?</h2><p><s>Chevrotain relies on <strong>Function.prototype.toString()</strong>. This means that certain aggressive minification options can break Chevrotain grammars.</s></p>`,8),C=n("The dependence on "),I=e("code",null,"Function.prototype.toString",-1),R=n(" was removed in "),N={href:"http://chevrotain.io/docs/changes/CHANGELOG.html#_6-0-0-8-20-2019",target:"_blank",rel:"noopener noreferrer"},O=n("version 6.0.0"),T=n(" of Chevrotain. Special handling is no longer needed during minification scenarios."),w=e("h2",{id:"WEBPACK",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#WEBPACK","aria-hidden":"true"},"#"),n(" Why does Chevrotain not work correctly after I webpacked my Grammar?")],-1),x=e("p",null,[e("s",null,[n("Chevrotain relies on "),e("strong",null,"Function.prototype.toString()"),n(". This means that certain webpack optimizations can break Chevrotain grammars.")])],-1),P=n("The dependence on "),G=e("code",null,"Function.prototype.toString",-1),A=n(" was removed in "),L={href:"http://chevrotain.io/docs/changes/CHANGELOG.html#_6-0-0-8-20-2019",target:"_blank",rel:"noopener noreferrer"},U=n("version 6.0.0"),W=n(" of Chevrotain. Special handling is no longer needed during WebPacking scenarios."),M=e("h2",{id:"STUCK_AMBIGUITY",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#STUCK_AMBIGUITY","aria-hidden":"true"},"#"),n(" Why does my parser appear to be stuck during its initialization?")],-1),D=n("The first time a Chevrotain parser is initialized additional validations and computations are performed. Some of these can take a very long time under certain edge cases. Specifically the detection of ambiguous alternatives when the parser uses a larger than the default "),F={href:"https://chevrotain.io/documentation/10_1_2/interfaces/iparserconfig.html#maxlookahead",target:"_blank",rel:"noopener noreferrer"},q=n("maxLookahead"),B=n(" and there are many (thousands) of ambiguous paths."),V=e("p",null,"To resolve this try reducing the maxLookahead and inspect the ambiguity errors to fix the grammar ambiguity which is the root cause of the problem.",-1),H=n("Also have a look at the "),J=n("Initialization Performance Guide");function Y(j,z){const t=i("ExternalLinkIcon"),o=i("RouterLink");return c(),p("div",null,[d,e("ul",null,[e("li",null,[e("p",null,[h,m,e("a",g,[f,a(t)]),_])]),v]),k,e("p",null,[b,a(o,{to:"/guide/internals.html#debugging-implications"},{default:r(()=>[S]),_:1}),y]),E,e("p",null,[C,I,R,e("a",N,[O,a(t)]),T]),w,x,e("p",null,[P,G,A,e("a",L,[U,a(t)]),W]),M,e("p",null,[D,e("a",F,[q,a(t)]),B]),V,e("p",null,[H,a(o,{to:"/guide/initialization_performance.html"},{default:r(()=>[J]),_:1})])])}var $=l(u,[["render",Y],["__file","FAQ.html.vue"]]);export{$ as default};
