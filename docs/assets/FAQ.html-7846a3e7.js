import{_ as p,r,o as u,c as d,a as o,b as e,d as a,e as t,w as l}from"./app-5079ec4e.js";const c={},h={href:"https://chevrotain.io/performance/",target:"_blank",rel:"noopener noreferrer"},m={href:"http://chevrotain.io/docs/changes/CHANGELOG.html#_6-0-0-8-20-2019",target:"_blank",rel:"noopener noreferrer"},g={href:"http://chevrotain.io/docs/changes/CHANGELOG.html#_6-0-0-8-20-2019",target:"_blank",rel:"noopener noreferrer"},f={href:"https://chevrotain.io/documentation/11_1_1/interfaces/IParserConfig.html",target:"_blank",rel:"noopener noreferrer"};function v(k,n){const s=r("ExternalLinkIcon"),i=r("RouterLink");return u(),d("div",null,[n[23]||(n[23]=o('<h1 id="faq" tabindex="-1"><a class="header-anchor" href="#faq" aria-hidden="true">#</a> FAQ</h1><ul><li><a href="#VS_GENERATORS">Why should I use a Parsing DSL instead of a Parser Generator?</a></li><li><a href="#VS_OTHERS">What Differentiates Chevrotain from other Parsing Libraries?</a></li><li><a href="#WHY_ERROR_RECOVERY">Why are Error Recovery / Fault Tolerant capabilities needed in a Parser?</a></li><li><a href="#DEBUGGING">How do I debug my parser?</a></li><li><a href="#NUMERICAL_SUFFIXES">Why are the unique numerical suffixes (CONSUME1/CONSUME2/...) needed for the DSL Rules?</a></li><li><a href="#MINIFIED">Why does Chevrotain not work correctly after I minified my Sources?</a></li><li><a href="#WEBPACK">Why does Chevrotain not work correctly after I webpacked my Sources?</a></li><li><a href="#STUCK_AMBIGUITY">Why does my parser appear to be stuck during its initialization?</a></li></ul><h2 id="VS_GENERATORS" tabindex="-1"><a class="header-anchor" href="#VS_GENERATORS" aria-hidden="true">#</a> Why should I use a Parsing DSL instead of a Parser Generator?</h2><p>A Parser Generator adds an (unnecessary) level of abstraction between the grammar implementation and the actual parser. This is because the grammar is written in a <strong>different</strong> language than the target runtime.</p><ul><li><p>Debugging a generated parser means looking at <strong>different</strong> code than the actual grammar specifications. This generated code is often huge, verbose and hard to understand. On the other hand, when debugging a Parser implemented using a Parsing DSL, The <strong>actual Grammar&#39;s code</strong> the implementer wrote(not generated code) is debugged. So debugging Chevrotain is <strong>just like</strong> debugging any other JavaScript code.</p></li><li><p>No need to handle grammar generation as part of the build process or commit generated files to the source code.</p></li><li><p>No need to learn a new syntax, as Chevrotain is a <strong>Pure</strong> JavasScript Library. instead the problem is reduced to learning a new API.</p></li><li><p>No need for a special editor to write the Grammar, just use your favorite JavaScript editor.</p></li></ul><h2 id="VS_OTHERS" tabindex="-1"><a class="header-anchor" href="#VS_OTHERS" aria-hidden="true">#</a> What Differentiates Chevrotain from other JavaScript Parsing Solutions?</h2>',6)),e("ul",null,[e("li",null,[e("p",null,[n[1]||(n[1]=e("strong",null,"Performance",-1)),n[2]||(n[2]=a(": Chevrotain is generally faster (often much more so) than other existing JavaScript Parsing Solutions. And can even compete with the performance of hand built parsers. See an ")),e("a",h,[n[0]||(n[0]=a("Online Benchmark")),t(s)]),n[3]||(n[3]=a(" that compares the performance of JSON Parsers implemented using multiple JavaScript Parsing solutions."))])]),n[4]||(n[4]=e("li",null,[e("p",null,[e("strong",null,"Error Recovery / Fault Tolerance"),a(": With the exception of Antlr4, other JavaScript Parsing Solutions usually do not have Error Recovery capabilities.")])],-1))]),n[24]||(n[24]=o('<h2 id="WHY_ERROR_RECOVERY" tabindex="-1"><a class="header-anchor" href="#WHY_ERROR_RECOVERY" aria-hidden="true">#</a> Why are Error Recovery / Fault Tolerant capabilities needed in a Parser?</h2><p>When building a standard compiler that should only handle completely valid inputs these capabilities are indeed irrelevant. But for the use case of building Editor Tools / Language Services the parser must be able to handle partially invalid inputs as well. Some examples:</p><ul><li>All syntax errors should be reported and not just the first one.</li><li>Refactoring should work even if there is a missing comma somewhere.</li><li>Autocomplete / Intellisense should work even if there is a syntax error prior to the requested suggestion position.</li></ul><h2 id="DEBUGGING" tabindex="-1"><a class="header-anchor" href="#DEBUGGING" aria-hidden="true">#</a> How do I debug my parser?</h2><p>Just add a breakpoint in your favorites IDE and debug, same as you would for any other JavaScript code. Chevrotain Grammars are <strong>pure</strong> javascript code. No special handling required.</p>',5)),e("p",null,[n[6]||(n[6]=a("Note that the breakpoints may also trigger during the Parser's initialization. See: the ")),t(i,{to:"/guide/internals.html#debugging-implications"},{default:l(()=>n[5]||(n[5]=[a("relevant section")])),_:1}),n[7]||(n[7]=a(" in grammar recording phase docs."))]),n[25]||(n[25]=o(`<h2 id="NUMERICAL_SUFFIXES" tabindex="-1"><a class="header-anchor" href="#NUMERICAL_SUFFIXES" aria-hidden="true">#</a> Why are the unique numerical suffixes (CONSUME1/CONSUME2/...) needed for the DSL Rules?</h2><p>Lets look at an example first:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token constant">RULE</span><span class="token punctuation">(</span><span class="token string">&quot;someRule&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  $<span class="token punctuation">.</span><span class="token constant">OPTION</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    $<span class="token punctuation">.</span><span class="token constant">CONSUME</span><span class="token punctuation">(</span>MyToken<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  $<span class="token punctuation">.</span><span class="token constant">OPTION1</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// A different suffix is not needed because the argument is different!</span>
    $<span class="token punctuation">.</span><span class="token constant">CONSUME</span><span class="token punctuation">(</span>MyOtherToken<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// OPTION has no &quot;named&quot; argument so a different suffix is **always** needed</span>
  <span class="token comment">// within the same top level rule.</span>
  $<span class="token punctuation">.</span><span class="token constant">OPTION2</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    $<span class="token punctuation">.</span><span class="token constant">CONSUME2</span><span class="token punctuation">(</span>MyToken<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This snippet uses three different variations of OPTION(&quot;&quot;|1|2) and two variations of CONSUME(&quot;&quot;|2). This is because during the parsing runtime Chevrotain must be able to <strong>distinguish</strong> between the variations of the <strong>same</strong> Parsing rule.</p><p>The combination of the DSL Rule(OPTION/MANY/CONSUME), the DSL Rule&#39;s optional numerical suffix and the DSL rule&#39;s parameter (if available) are mapped to a <strong>unique</strong> key which Chevrotain uses to <strong>figure out</strong> the current location in the grammar. This location information is then used for many things such as:</p><ul><li>Computing the lookahead function which decides if a DSL rule should be entered or which alternatives should be taken.</li><li>Computing an appropriate error message which includes the list of next valid possible tokens.</li><li>Performing automatic Error Recovery by figuring out &quot;re-sync&quot; tokens.</li></ul><h2 id="MINIFIED" tabindex="-1"><a class="header-anchor" href="#MINIFIED" aria-hidden="true">#</a> Why does Chevrotain not work correctly after I minified my Grammar?</h2><p><s>Chevrotain relies on <strong>Function.prototype.toString()</strong>. This means that certain aggressive minification options can break Chevrotain grammars.</s></p>`,8)),e("p",null,[n[9]||(n[9]=a("The dependence on ")),n[10]||(n[10]=e("code",null,"Function.prototype.toString",-1)),n[11]||(n[11]=a(" was removed in ")),e("a",m,[n[8]||(n[8]=a("version 6.0.0")),t(s)]),n[12]||(n[12]=a(" of Chevrotain. Special handling is no longer needed during minification scenarios."))]),n[26]||(n[26]=e("h2",{id:"WEBPACK",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#WEBPACK","aria-hidden":"true"},"#"),a(" Why does Chevrotain not work correctly after I webpacked my Grammar?")],-1)),n[27]||(n[27]=e("p",null,[e("s",null,[a("Chevrotain relies on "),e("strong",null,"Function.prototype.toString()"),a(". This means that certain webpack optimizations can break Chevrotain grammars.")])],-1)),e("p",null,[n[14]||(n[14]=a("The dependence on ")),n[15]||(n[15]=e("code",null,"Function.prototype.toString",-1)),n[16]||(n[16]=a(" was removed in ")),e("a",g,[n[13]||(n[13]=a("version 6.0.0")),t(s)]),n[17]||(n[17]=a(" of Chevrotain. Special handling is no longer needed during WebPacking scenarios."))]),n[28]||(n[28]=e("h2",{id:"STUCK_AMBIGUITY",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#STUCK_AMBIGUITY","aria-hidden":"true"},"#"),a(" Why does my parser appear to be stuck during its initialization?")],-1)),e("p",null,[n[19]||(n[19]=a("The first time a Chevrotain parser is initialized additional validations and computations are performed. Some of these can take a very long time under certain edge cases. Specifically the detection of ambiguous alternatives when the parser uses a larger than the default ")),e("a",f,[n[18]||(n[18]=a("maxLookahead")),t(s)]),n[20]||(n[20]=a(" and there are many (thousands) of ambiguous paths."))]),n[29]||(n[29]=e("p",null,"To resolve this try reducing the maxLookahead and inspect the ambiguity errors to fix the grammar ambiguity which is the root cause of the problem.",-1)),e("p",null,[n[22]||(n[22]=a("Also have a look at the ")),t(i,{to:"/guide/initialization_performance.html"},{default:l(()=>n[21]||(n[21]=[a("Initialization Performance Guide")])),_:1})])])}const S=p(c,[["render",v],["__file","FAQ.html.vue"]]);export{S as default};
